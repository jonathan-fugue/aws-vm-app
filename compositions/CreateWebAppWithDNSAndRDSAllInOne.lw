composition

import Fugue.AWS.Route53.ResourceRecordSet.Base as ResourceRecordSet
import Fugue.AWS.Route53.HostedZone as HostedZone
import Fugue.Core.AWS.Route53 as Route53

import Fugue.AWS.Pattern.Network as Network

network: Network.new {
  name: "public network",
  cidr: "10.0.0.0/16",
  region: AWS.Us-east-1,
  publicSubnets: [
    (AWS.A, "10.0.0.0/24"),
    (AWS.B, "10.0.1.0/24"),
  ],
  privateSubnets: [],
  enableDnsSupport: True,
  enableDnsHostnames: True,
}

webApp: new {
  name: "Demo",
  subnets: network.publicSubnets,
  withRDS: True,
  userData:
    "#cloud-config
    \packages: nginx",
}

webAppR53Alias: ResourceRecordSet.new {
  name: "www.example.com",
  recordType: Route53.A,
  hostedZone: HostedZone.external("Z3UKP9OC5NOVGW"),
  resourceRecords: [],
  aliasTarget: Route53.LoadBalancerAliasTarget {
    loadBalancer: webApp.(WebApp).elb,
    evaluateTargetHealth: True,
  }
}

export
  type WebApp
  type WebAppSecurityGroups
  new

import Fugue.AWS.AutoScaling as AutoScaling
import Fugue.AWS.EC2 as EC2
import Fugue.AWS.ELB as ELB
import Fugue.AWS.IAM as IAM
import Fugue.AWS.RDS as RDS
import Fugue.AWS as AWS
import Fugue.Core.Vars as Vars

type WebApp:
  | WebApp
    elb: ELB.LoadBalancer
    asg: AutoScaling.AutoScalingGroup
    sgs: WebAppSecurityGroups
    db: Optional<RDS.DBInstance>

type WebAppSecurityGroups:
  elbSg: EC2.SecurityGroup
  asgSg: EC2.SecurityGroup
  rdsSg: Optional<EC2.SecurityGroup>
  clientSg: EC2.SecurityGroup

validate validateInstanceType

fun validateInstanceType(t: WebApp) -> Validation:
  let lc: t.WebApp.asg.(AutoScaling.AutoScalingGroup).launchConfiguration
  let instanceType: lc.(AutoScaling.LaunchConfiguration).instanceType
  case instanceType of
    | EC2.T2_micro  -> Validation.success
    | EC2.T2_small  -> Validation.success
    | EC2.T2_medium -> Validation.success
    | _             -> Validation.failure("Must be a valid EC2 instance type.")

fun amiForRegion(region: AWS.Region) -> String:
  case region of
    | AWS.Us-east-1 -> "ami-a60c23b0"
    | AWS.Us-west-1 -> "ami-96f1dcf6"
    | AWS.Us-west-2 -> "ami-7646530f"
    | AWS.Eu-west-1 -> "ami-af455dc9"
    | _ -> AWS.Region.toString(region) ++ " is not supported."

fun makeWebAppSgs {
      name: String,
      vpc: EC2.Vpc,
      withRDS: Optional<Bool>,
      extraTags: List<AWS.Tag>
    } -> WebAppSecurityGroups:
  let _withRDS: Optional.unpack(False, withRDS)
  let elbSg: EC2.SecurityGroup.new {
    description: name ++ "-elb-sg",
    ipPermissions: [
      EC2.IpPermission.http(EC2.IpPermission.Target.all),
      EC2.IpPermission.https(EC2.IpPermission.Target.all),
    ],
    tags: List.concat([AWS.tag("Name", name ++ "-elb-sg")], extraTags),
    vpc: vpc,
  }
  let asgSg: EC2.SecurityGroup.new {
    description: name ++ "-asg-sg",
    ipPermissions: [
      EC2.IpPermission.ssh(EC2.IpPermission.Target.securityGroups([clientSg])),
      EC2.IpPermission.http(EC2.IpPermission.Target.securityGroups([elbSg])),
      EC2.IpPermission.https(EC2.IpPermission.Target.securityGroups([elbSg])),
    ],
    tags: List.concat([AWS.tag("Name", name ++ "-asg-sg")], extraTags),
    vpc: vpc,
  }
  let rdsSg:
    if _withRDS then
      Optional(EC2.SecurityGroup.new {
        description: name ++ "-rds-sg",
        ipPermissions: [
          EC2.IpPermission.mysql(EC2.IpPermission.Target.securityGroups([clientSg]))
        ],
        tags: List.concat([AWS.tag("Name", name ++ "-rds-sg")], extraTags),
        vpc: vpc,
      })
    else
      None
  let clientSg: EC2.SecurityGroup.new {
    description: name ++ "-client-sg",
    ipPermissions: [],
    tags: List.concat([AWS.tag("Name", name ++ "-client-sg")], extraTags),
    vpc: vpc,
  }
  {
    elbSg: elbSg,
    asgSg: asgSg,
    rdsSg: rdsSg,
    clientSg: clientSg,
  }

fun new {
      name: String,
      subnets: List<EC2.Subnet>,
      vpc: Optional<EC2.Vpc>,
      region: Optional<AWS.Region>,
      keyName: Optional<String>,
      image: Optional<String>,
      userData: Optional<String>,
      instanceType: Optional<EC2.InstanceType>,
      managementSgs: Optional<List<EC2.SecurityGroup>>,
      withRDS: Optional<Bool>,
      dbEngine: Optional<RDS.Engine>,
      dbInstanceClass: Optional<RDS.DBInstanceClass>,
      dbStorageType: Optional<EC2.VolumeType>,
      dbAllocatedStorage: Optional<Int>,
      dbMultiAZ: Optional<Bool>,
      dbName: Optional<String>,
      dbMasterUsername: Optional<String>,
      dbMasterUserPassword: Optional<Vars.Password>,
      tags: Optional<List<AWS.Tag>>
    } -> WebApp:
  let _vpc: Optional.unpack(List.index(subnets,0).(EC2.Subnet).vpc, vpc)
  let _region: Optional.unpack(_vpc.(EC2.Vpc).region, region)
  let _keyName:              Optional.unpack(name, keyName)
  let _image:                Optional.unpack(amiForRegion(_region), image)
  let _userData:             Optional.unpack(" ", userData)
  let _instanceType:         Optional.unpack(EC2.T2_micro, instanceType)
  let _withRDS:              Optional.unpack(False, withRDS)
  let _dbEngine:             Optional.unpack(RDS.MySQL, dbEngine)
  let _dbInstanceClass:      Optional.unpack(RDS.DB_T2_MICRO, dbInstanceClass)
  let _dbStorageType:        Optional.unpack(EC2.Standard, dbStorageType)
  let _dbAllocatedStorage:   Optional.unpack(10, dbAllocatedStorage)
  let _dbMultiAZ:            Optional.unpack(False, dbMultiAZ)
  let _dbName:               Optional.unpack(name, dbName)
  let _dbMasterUsername:     Optional.unpack("root", dbMasterUsername)
  let _dbMasterUserPassword: Optional.unpack(Vars.VarsKey({key: "/rds/password"}), dbMasterUserPassword)
  let _managementSgs:        Optional.unpack([], managementSgs)
  let _extraTags:            Optional.unpack([], tags)

  let sgs: makeWebAppSgs {
    name: name,
    vpc: _vpc,
    withRDS: _withRDS,
    extraTags: _extraTags,
  }

  let policy: IAM.Policy.new {
    policyName: name ++ "-policy",
    policyDocument: '{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": "*",
          "Resource": "*"
        }
      ]
    }',
  }
  let role: IAM.Role.new {
    roleName: name ++ "-role",
    rolePolicies: [policy],
    assumeRolePolicyDocument: IAM.Policy.AssumeRole.ec2,
  }
  let profile: IAM.InstanceProfile.new {
    instanceProfileName: name ++ "-profile",
    roles: [role],
  }

  let elb:  ELB.LoadBalancer.new {
    loadBalancerName: name ++ "-elb",
    listeners: [
      ELB.Listener.new {
        protocol: ELB.TCP,
        loadBalancerPort: 80,
        instancePort: 80,
        instanceProtocol: ELB.TCP,
      },
      ELB.Listener.new {
        protocol: ELB.TCP,
        loadBalancerPort: 443,
        instancePort: 443,
        instanceProtocol: ELB.TCP,
      }
    ],
    healthCheck: ELB.HealthCheck.tcp {
      port: 80,
      interval: 5,
      timeout: 2,
      unhealthyThreshold: 2,
      healthyThreshold: 2,
    },
    subnets: subnets,
    securityGroups: [sgs.elbSg],
    tags: List.concat([AWS.tag("Name", name)], _extraTags),
  }

  let lc: AutoScaling.LaunchConfiguration.new {
    image: _image,
    securityGroups: List.concat([sgs.asgSg], _managementSgs),
    keyName: _keyName,
    instanceType: _instanceType,
    associatePublicIpAddress: True,
    iamInstanceProfile: profile,
    userData: _userData, 
  }
  let asg: AutoScaling.AutoScalingGroup.new {
    subnets: subnets,
    loadBalancers: [elb],
    minSize: 1,
    maxSize: 2,
    defaultCooldown: 300,
    healthCheckType: AutoScaling.Ec2,
    launchConfiguration: lc,
    tags: List.concat([AWS.tag("Name", name)], _extraTags),
    terminationPolicies: [AutoScaling.ClosestToNextInstanceHour],
    enabledMetrics: [
      AutoScaling.GroupInServiceInstances,
      AutoScaling.GroupTotalInstances,
    ]
  }

  let db:
    if _withRDS then
      let subnetGroup: RDS.DBSubnetGroup.new {
        name: name,
        description: name ++ "-subnet-group",
        subnets: subnets,
        tags: List.concat([AWS.tag("Name", name)], _extraTags),
      }
      let _rdsSg: Optional.unpackOrError(sgs.rdsSg, "Fail")
      Optional(RDS.DBInstance.new {
        dbName: _dbName,
        dbInstanceIdentifier: name ++ "-dbInstance",
        dbInstanceClass: _dbInstanceClass,
        engine: _dbEngine,
        masterUsername: _dbMasterUsername,
        allocatedStorage: _dbAllocatedStorage,
        securityGroups: [_rdsSg],
        availabilityZone: None,
        dbSubnetGroup: subnetGroup,
        multiAZ: _dbMultiAZ,
        publiclyAccessible: True,
        storageType: _dbStorageType,
        masterUserPassword: _dbMasterUserPassword,
        tags: List.concat([AWS.tag("Name", name)], _extraTags),
      })
    else
      None
  WebApp {
    sgs: sgs,
    elb: elb,
    asg: asg,
    db: db,
  }
